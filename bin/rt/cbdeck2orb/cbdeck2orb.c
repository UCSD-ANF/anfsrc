#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <thread.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/uio.h>
#include <errno.h>
#include <strings.h>
#include <orb.h>
#include <Pkt.h>

/*
 Copyright (c) 2003 The Regents of the University of California
 All Rights Reserved
 
 Permission to use, copy, modify and distribute any part of this software for
 educational, research and non-profit purposes, without fee, and without a
 written agreement is hereby granted, provided that the above copyright
 notice, this paragraph and the following three paragraphs appear in all
 copies.
 
 Those desiring to incorporate this software into commercial products or use
 for commercial purposes should contact the Technology Transfer Office,
 University of California, San Diego, 9500 Gilman Drive, La Jolla, CA
 92093-0910, Ph: (858) 534-5815.
 
 IN NO EVENT SHALL THE UNIVESITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE, EVEN IF THE UNIVERSITY
 OF CALIFORNIA HAS BEEN ADIVSED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 THE SOFTWARE PROVIDED HEREIN IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.  THE UNIVERSITY OF CALIFORNIA MAKES NO
 REPRESENTATIONS AND EXTENDS NO WARRANTIES OF ANY KIND, EITHER IMPLIED OR
 EXPRESS, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR THAT THE USE OF THE
 SOFTWARE WILL NOT INFRINGE ANY PATENT, TRADEMARK OR OTHER RIGHTS.

   This code was created as part of the ROADNet project.
   See http://roadnet.ucsd.edu/ 

   Written By: Steve Foley 6/17/2004
   Last Updated By: Steve Foley 6/23/2004
*/

#define CALIB_FACTOR       100000000000
#define KEEPALIVE_TIMEOUT  5
#define NUM_CHANNELS      16
#define TIMESTAMP_LENGTH  24
#define VERSION "$Revision: 1.1 $"

/* GLOBALS */
static int VERBOSE = 0;

/* PROTOTYPES */
void usage(void);
int add_sample(char *, char *, int, int, Packet **);
void submit_packet(int, char *, Packet *);

void usage(void)
{
  cbanner(VERSION,
	  "[-V] [-v] [-h] -p port -s srcname -o orbname -n nsamps -r samplerate\n",
	  "Steve Foley","UCSD ROADNet Project","sfoley@ucsd.edu");
}

/* Submit an already generated packet to the orb.
 * Frees packet generated by add_sample() after submission.
 * Param: orbfd - The open file descriptor for the orb being submitted to
 * Param: srcname - The name of the source being submitted to in 
 *                  NET_STA format.
 * Param: pkt - The non-null packet being submitted.
 */
void
submit_packet(int orbfd, char *srcname, Packet *in_pkt)
{
  double        newtimestamp;
  static char   *newpkt = NULL;
  int           newpkt_size;
  static int    newpkt_alloc_size = 0;
  int           ret;

  /* check args for nulls */
  if (orbfd < 0)
    {
      elog_complain(1, "Attempt to closed orbfd. Failing!");
    }

  if (VERBOSE)
    {
      elog_notify(0, "Submitting packet to ORB\n");
    }
  
  /* stuff and check the packet */
  if ((ret=stuffPkt(in_pkt, srcname, &newtimestamp, &newpkt, &newpkt_size,
		    &newpkt_alloc_size)) < 0)
    {
      elog_complain(1, "stuffPkt routine failed (ret=%d)",ret);
    }
  else if (orbput(orbfd, srcname, newtimestamp, newpkt, newpkt_size) < 0)
    {
      
      elog_complain(1, "orbput fails %s\n", srcname);
    }
  else if (VERBOSE)
    {
      showPkt(0, srcname, newtimestamp, newpkt, newpkt_size, stdout,
	      PKT_UNSTUFF);
    }

  freePkt(in_pkt);
}

/* Add a sample to the packet that is passed in. These packets of
 * data will be collected and bundled up into MGENC packets with
 * nsamps samples in them for efficiency.
 * Param: buffer - The buffer of ASCII characters to put into the channels
 * Param: srcname - The source name to add the samples to in NET_STA format
 * Param: nsamp - The number of samples that will ultimately go in a packet
 * Param: sample_rate - The number of samples per second
 * Param: pkt - A reference to the packet where the data is stored. 
 *              If the value pointed to is NULL, a new Packet is created
 *              and the first values are stuffed into it.
 * Return: The number of packet samples that are now in the packet, -1 for
 *         an error such as a bad timestamp.
 */
int
add_sample(char *buffer, char *srcname, int nsamp, int 
	   sample_rate, Packet **in_pkt)
{
  Packet        *pkt;
  PktChannel    *pktchan;
  double 	pkttime = 0;
  int           loop;	
    
  Tbl           *valTbl;
  double        chan_data[NUM_CHANNELS];
  long          int_chan_data[NUM_CHANNELS];
  char          *short_timestamp, *tblValue;
  char          timestamp[STRSZ];
  Srcname       src_parts;
  int           fresh_pkt = 0;

  if (VERBOSE)
    {
      elog_notify(0, "Adding sample with buffer: [%s]\n",buffer);
    }
  
  /* parse some input to have data for a new packet */
  valTbl = split(buffer, ',');

  short_timestamp = shifttbl(valTbl);
  memset(timestamp, '\0', STRSZ);
  strncpy(timestamp, short_timestamp, strlen(short_timestamp)+1);
  strncat(timestamp, " US/Pacific", 11);
  split_srcname(srcname, &src_parts);
  
  /* translate timestamp */
  if (zstr2epoch(timestamp, &pkttime) != 0)
    {
      elog_notify(0, "Bad packet timestamp: [%s]...returning!\n", timestamp);
      freetbl(valTbl, NULL);
      return -1;
    }

  /* check to see if packet is null. If so, create a new packet */
  /* via a function call that setups up the basic packet structure */
  if (in_pkt[0] == NULL)
    {
      fresh_pkt = 1;
      pkt = newPkt();
      pkt->time = pkttime;
      if ((pkt->pkttype = suffix2pkttype("MGENC")) == 0)
	{
	  elog_notify(0, "Could not find MGENC structure!\n");
	}
      pkt->nchannels=NUM_CHANNELS;      
      strncpy(pkt->parts.src_net, src_parts.src_net, PKT_TYPESIZE);
      strncpy(pkt->parts.src_sta, src_parts.src_sta, PKT_TYPESIZE);
      *(pkt->parts.src_chan)=0;
      *(pkt->parts.src_loc)=0;
    }
  else 
    {
      pkt = in_pkt[0]; 
    }
  
  /* if the packet exists, walk through the channels and add data */
  /* Be sure to increase datasz */
  for (loop = 0; loop < NUM_CHANNELS; loop++)
    {
      tblValue = shifttbl(valTbl);
      
      if (tblValue != NULL)
	{
	  if (fresh_pkt)
	    {
	      pktchan = newPktChannel();
	      pktchan->datasz = 0;
	      pktchan->time = pkttime;
	      pktchan->nsamp = nsamp;
	      strncpy(pktchan->net, src_parts.src_net, PKT_TYPESIZE);
	      strncpy(pktchan->sta, src_parts.src_sta, PKT_TYPESIZE);
	      sprintf(pktchan->chan, "%03d", (loop+1));
	      sprintf(pktchan->loc, "%03d", (loop+1));

	      /*	      *(pktchan->loc)='\0'; */
	      strncpy(pktchan->segtype, "c", 2);
	      pktchan->calper = -1;
	      pktchan->calib = 1.0/CALIB_FACTOR;
	      pktchan->samprate = sample_rate;

	      /* allocate lots of memory for the data */
	      pktchan->data = malloc(nsamp * sizeof(long));
	      if (pktchan->data == NULL)
		{
		  freetbl(valTbl, NULL);
		  die(1, "Could not malloc for channel data!\n");
		}
	      
	    }
	  else
	    {
	      /* get the old PktChannel out and add to the data array */
	      pktchan = ((PktChannel *) gettbl(pkt->channels,loop));
	      if (pktchan == NULL)
		{
		  elog_complain(1, "Missing packet channel %d in packet", 
				loop);
		  break;
		}
	    }

	  
	  /* parse the data and put it in the channel array */
	  
	  chan_data[loop] = strtod(tblValue, NULL);
	  int_chan_data[loop] = (long)(chan_data[loop]*CALIB_FACTOR);
	  
	  /* datasz is # of samples, but we are one ahead. data is 0 based */
	  pktchan->data[pktchan->datasz++] = (CALIB_FACTOR * chan_data[loop]);

	  /* add it to the packet, but only if it is new */
	  if (fresh_pkt)
	    {
	      pushtbl(pkt->channels,pktchan);
	    }
	  if (VERBOSE)
	    {
	      elog_notify(0,"chan %d: val: %e, int_val: %d\n", 
			  loop, chan_data[loop], 
			  pktchan->data[(pktchan->datasz)-1]);
	    }
	}
    }
  
  /* free resources */
  freetbl(valTbl, NULL);

  if (VERBOSE)
    {
      elog_notify(0, "Added sample to packet. %d samples so far.\n",
		  pktchan->datasz);
    }

  in_pkt[0] = pkt;
  return pktchan->datasz;
}

/*** MAIN ***/
main( int argc, char *argv[] )
{
	struct sockaddr_in sin;
	in_port_t port;
	int 	sockfd, newsockfd, clilen;
	struct sockaddr_in cli_addr;
	char	c;
	char	*orbname = NULL;
	char	*srcname;
	char	input_buffer[STRSZ], submit_buffer[STRSZ];
	int 	orbfd;
	int	isentence, synced, streamchar;
	int     lcv, high_fd, val;
	int     connected, filedes;
	fd_set  read_fds, except_fds;
	struct timeval timeout;
	char     ch;
	int     required_args = 0;
	int     loop = 0;
	ssize_t numchars;
	int     nsamps = 1;
	int     sample_rate = nsamps;
	Packet  *pkt = 0;

	connected = 0;
	orbfd = -1;
	synced = 0;
	memset(submit_buffer, '\0', STRSZ);
	isentence = 0;
	

	elog_init( argc, argv );
	while ((ch = getopt(argc, argv, "Vvhp:s:o:n:r:")) != -1)
	  switch (ch) {
	  case 'v':   /* verbose */
	    VERBOSE = 1;
	    break;
	  case 'h':   /* help */              
	    usage();
	    exit(-1);
	  case 'V':   /* version */
	    usage();
	    exit(-1);
	  case 'p':   /* port */
	    port=atoi(optarg);
	    required_args++;
	    break;
	  case 's':   /* source */
	    srcname = optarg;
	    required_args++;
	    break;
	  case 'o':   /* orbname */
	    orbname = optarg;
	    required_args++;
	    break;
	  case 'n':   /* nsamps */
	    nsamps = atoi(optarg);
	    required_args++;
	    break;
	  case 'r':   /* nsamps */
	    sample_rate = atoi(optarg);
	    required_args++;
	    break;
	  default:
	    printf("\n");
	    usage();
	    exit(-1);
	  }
	
	if (required_args < 5)
	  {
	    usage();
	    exit(-1);
	  }

	
	if( ( orbfd = orbopen( orbname, "w&" ) ) < 0 ) 
	  {
	    die( 1, "Couldn't open %s\n", orbname );
	  } 

	sockfd = socket( PF_INET, SOCK_STREAM, 0 );
	if( sockfd < 0 ) {
	  if (orbfd >= 0) 
	    {
	      orbclose(orbfd);
	    }
	  die( 1, "Can't open tcp socket for cbdeck acquisition\n" );
	}

	sin.sin_family = AF_INET;
	sin.sin_port = htons( (in_port_t) port );
	sin.sin_addr.s_addr = htonl( INADDR_ANY );

	
	if( bind( sockfd, (struct sockaddr *) &sin, sizeof( sin ) ) ) {
	  if (orbfd >= 0) 
	    {
	      orbclose(orbfd);
	    }
	  die( 1, "Couldn't bind cbdeck acquisition socket\n" );
	}
		
	
	listen(sockfd, 0);

	/* now that we are listening, try to accept a connection forever */
	while (1)
	  {
	    if (VERBOSE)
	      {
		elog_notify(0, "Starting infinite loop...\n");
	      }

	    FD_ZERO(&except_fds);
	    FD_SET(sockfd,&except_fds);
	    FD_ZERO(&read_fds);
	    FD_SET(sockfd,&read_fds);
	    high_fd=sockfd+1;
	    
	    if (connected)
	      {
		FD_SET(filedes,&read_fds);
		if (filedes>=high_fd)
		  high_fd=filedes+1;
	      }
	    
	    timeout.tv_sec=KEEPALIVE_TIMEOUT;
	    timeout.tv_usec=0;
	    
	    /* select instead of accept so we dont block */
	    /* in case we get disconnected */
	    if (VERBOSE)
	      {
		elog_notify(0, 
		     "Before select, connected=%d, sockfd=%d, high_fd=%d...\n",
			    connected, sockfd, high_fd);
	      }
	    lcv=select(high_fd,&read_fds,0,&except_fds,&timeout);

	    	
	      if (lcv<0)
	      {
		if (orbfd >= 0) 
		  {
		    orbclose(orbfd);
		  }
		die(1, "select error\n");
	      }
	    
	    
	    else if (lcv==0)
	      {
		/* timeout expired, no one writing... assume dead */
	      }
	    else if (FD_ISSET(sockfd,&read_fds) 
		     || FD_ISSET(sockfd,&except_fds))
	      {
		/* someone wants to connect */
		clilen = sizeof(cli_addr);
		newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, 
				   &clilen);
		if (newsockfd < 0)
		  {
		    if (orbfd >= 0) 
		      {
			orbclose(orbfd);
		      }
		    die(1, "accept error!\n");
		  }
		val=1;
		
		if (setsockopt(newsockfd,SOL_SOCKET,SO_KEEPALIVE,&val,
			       sizeof(int)))
		  {
		    if (orbfd >= 0) 
		      {
			orbclose(orbfd);
		      }
		    die(1, "setsockopt(SO_KEEPALIVE)\n");
		  }
		
		if (connected)
		  {
		    elog_notify(0, "Already connected to a host! Dropping new connection!\n");
		    close(newsockfd);
		    connected=0;
		  }
		else
		  {
		    /* we are connected now, with a fresh connection */
		    connected = 1;
		    filedes = newsockfd;
		  }
	      } /* selected */

	    else  /* no bits set, select was postitive result...data pending */
	      {
		while ((numchars = read(filedes, input_buffer, STRSZ)) &&
		       (numchars > 0))
		  {
		    if (VERBOSE)
		      {
			elog_notify(0, "RECEIVED: %s\n",input_buffer);
		      }
		    for (loop = 0; loop < numchars; loop++)
		      {
			/* Did we get an end marker? */
			switch (input_buffer[loop]) {

			case '\r':
			  /* if we are synced, add to the ORB, else reset */
			  if (synced)
			    {
			      if (add_sample(submit_buffer, 
					     srcname, nsamps, 
					     sample_rate, &pkt) == nsamps)
				{
				  submit_packet(orbfd, srcname, pkt);
				  /* freed by submit, clear pointer */
				  pkt = 0;
				}
			      memset(submit_buffer, '\0', STRSZ);
			      isentence = 0;
			    }
			  else
			    {
			      memset(submit_buffer, '\0', STRSZ);
			      synced = 1;
			      isentence = 0;
			    }
			  break;

			case '\n':
			  memset(submit_buffer, '\0', STRSZ);
			  synced = 0;
			  isentence = 0;
			  break;

			default:
			  /* if we run off the end, start over */
			  if (isentence >= STRSZ)
			    {
			      memset(submit_buffer, '\0', STRSZ);
			      synced = 0;
			      isentence = 0;
			    }
			  else
			    {
			      submit_buffer[isentence++] 
				= input_buffer[loop]; 
			    }
			  break;
			};
		      }
		  }
		elog_notify(0, "Dropping connection!\n");
		connected = 0;
		close(filedes);
	      }
	      
	  } /* end while(1) */
}
