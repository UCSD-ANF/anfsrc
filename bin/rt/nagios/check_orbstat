#!/opt/antelope/current/bin/perl -wT

#
# Copyright (c) 2003 The Regents of the University of California
# All Rights Reserved
#
# Permission to use, copy, modify and distribute any part of this software for
# educational, research and non-profit purposes, without fee, and without a
# written agreement is hereby granted, provided that the above copyright
# notice, this paragraph and the following three paragraphs appear in all
# copies.
#
# Those desiring to incorporate this software into commercial products or use
# for commercial purposes should contact the Technology Transfer Office,
# University of California, San Diego, 9500 Gilman Drive, La Jolla, CA
# 92093-0910, Ph: (858) 534-5815.
#
# IN NO EVENT SHALL THE UNIVESITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE, EVEN IF THE UNIVERSITY
# OF CALIFORNIA HAS BEEN ADIVSED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# THE SOFTWARE PROVIDED HEREIN IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.  THE UNIVERSITY OF CALIFORNIA MAKES NO
# REPRESENTATIONS AND EXTENDS NO WARRANTIES OF ANY KIND, EITHER IMPLIED OR
# EXPRESS, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR THAT THE USE OF THE
# SOFTWARE WILL NOT INFRINGE ANY PATENT, TRADEMARK OR OTHER RIGHTS.
#
#   This code was created as part of the ROADNet project.
#   See http://roadnet.ucsd.edu/
#
#   Written By: Steve Foley 5/5/2004
# 
# Based on some code in the check_mailq program from Nagios Plugins v1.3.1

use Socket;
use Getopt::Long;
use vars qw($opt_version $opt_help $opt_verbose $opt_warn $opt_crit $opt_orb
	    $opt_source $opt_type $opt_index $opt_param $option_e 
	    $warn_at $warn_low $warn_high $crit_at $crit_low $crit_high
	    $VERBOSE $PROGNAME $STATE);


use lib "/opt/nagios/libexec";
use utils qw(%ERRORS); #OK, WARNING, CRITICAL, UNKNOWN, DEPENDENT
# antelope includes
use lib "/opt/antelope/current/data/perl";
use orb;
use Datascope;
use Socket;

# Prototypes
sub check_args();
sub print_version();
sub print_verbose();
sub print_help();
sub print_usage();
sub get_latest_orbstat_packet($);
sub check_recent_packet_exists($$$$$);
sub check_recent_pforbstat_packet_value($$$$$$$$);
sub print_results($$$);
sub parse_range();
sub categorize_return_value($);
sub check_range($$$$);
sub convert_pforbstat_to_numbers($);

# Constants
$VERSION = "1.0";
$AUTHOR = "Steve Foley, UCSD ROADNet Project, sfoley\@ucsd.edu";
$PROGNAME = $0;
$SERVER_TYPE = "server";
$CLIENT_TYPE = "clients";
$SOURCE_TYPE = "sources";
$TYPE_REGEX = "$SERVER_TYPE|$CLIENT_TYPE|$SOURCE_TYPE";
$ORBSERVER_NAMES_FILE = "/opt/antelope/current/data/pf/orbserver_names.pf";

# Defaults
$VERBOSE = 0;
$ORB = ":roadnet"; # orb and port, ie. "orbstat -s $ORB"

######
#
MAIN:
{

    my ($result_code, $result_perf);
    Getopt::Long::Configure("bundling");
    $status = check_args();
    if ($status)
    {
	print "ERROR: processing arugments\n";
	exit $ERRORS{'UNKNOWN'};
    }
    
    my ($pktid, $source_name, $packet_time, $raw_packet, $num_bytes)
	= get_latest_orbstat_packet($opt_source);
    
    # check if you have a packet first
    if (!defined $pktid)
    {
	print "ERROR: No orbstat packet found\n";
	exit $ERRORS{'UNKNOWN'};
    }
    elsif (defined $opt_type) 
    {
	($result_code, $result_perf)
	    = check_recent_pforbstat_packet_value($pktid, $source_name,
						  $packet_time,
						  $raw_packet, $num_bytes,
						  $opt_type, $opt_index,
						  $opt_param);
	if ($opt_type eq $SERVER_TYPE)
	{
	    print_results($result_code, $result_perf,
			  "$opt_type:$opt_param");
	}
	else
	{
	    print_results($result_code, $result_perf,
			  "$opt_type:$opt_index:$opt_param");
	}
	exit $result_code;
    }
    elsif (defined $opt_exists)
    {
	($result_code, $result_perf) 
	    = check_recent_packet_exists($pktid, $source_name, $packet_time, 
					 $raw_packet, $num_bytes);
	# pretty print if it isnt an error
	if ($result_code != $ERRORS{'UNKNOWN'})
	{
	    print_results($result_code, strtdelta($result_perf), 
			  "last packet age");
	}
	else
	{
	    print_results($result_code, $result_perf, 
			  "last packet age");	    
	}
	exit $result_code;
    }
    else
    {
	exit $ERRORS{'UNKNOWN'};
    }
}

######
# Check the arguments supplied 
sub check_args()
{
    my ($fetching_params) = 0;

    GetOptions("V"     => \$opt_version,  "version"  => \$opt_version,
	       "v"     => \$opt_verbose,  "verbose"  => \$opt_verbose,
	       "h"     => \$opt_help,     "help"     => \$opt_help,
	       "w=s"   => \$opt_warn,     "warn=s"   => \$opt_warn,
	       "c=s"   => \$opt_crit,     "crit=s"   => \$opt_crit,
	       "o=s"   => \$opt_orb,      "orb=s"    => \$opt_orb,
	       "s=s"   => \$opt_source,   "source=s" => \$opt_source,
	       "e"     => \$opt_exists,   "exists"   => \$opt_exists,
	       "t=s"   => \$opt_type,     "type=s"   => \$opt_type,
	       "i=s"   => \$opt_index,    "index=s"  => \$opt_index,
	       "p=s"   => \$opt_param,    "param=s"  => \$opt_param
	       );
    
    # handle options here
    if ($opt_version)
    {
	print_version();
	exit $ERRORS{'OK'};
    }
    
    if ($opt_verbose)
    {
	$VERBOSE = 1;
    }
    
    if ($opt_help)
    {
	print_help();
	exit $ERRORS{'OK'};
    }
    
    if ($opt_orb)
    {
	$ORB = $opt_orb;
    }
    
    # Gotta have warn, crit, and source options
    if (!defined $opt_source)
    {
	print_usage();
	exit $ERRORS{'UNKNOWN'};
    }

    # Gotta have either "exists" or "type/index/param" info
    if (defined $opt_type)
    {
	# Yeah, its a clunky set of IFs, but it reads clearer than one biggie
	if ($opt_type !~ /$TYPE_REGEX/)
	{
	    print_usage();
	    exit $ERRORS{'UNKNOWN'};	
	}	

	# server doesnt need an index...there is only one server!
	if (($opt_type ne $SERVER_TYPE) && (!defined $opt_index))
	{
	    print_usage();
	    exit $ERRORS{'UNKNOWN'};	
	}	

	# 
	if (!defined $opt_param)
	{
	    print_usage();
	    exit $ERRORS{'UNKNOWN'};		    
	}
    }
    elsif (!defined $opt_exists) # no type, so must exist or an error
    {
	print_usage();
	exit $ERRORS{'UNKNOWN'};	
    }

    if ($opt_source)
    {
	$opt_source = &convert_pforbstat_to_numbers($opt_source);
    }

    # Either both defined or neither of them
    if (((!defined $opt_warn) && (defined $opt_crit))
	|| ((defined $opt_warn) && (!defined $opt_crit)))
    {
	print_usage();
	exit $ERRORS{'UNKNOWN'};
    }

    # sanity check critical and warn flags
    if ((defined $opt_warn) && (defined $opt_crit) && (!parse_ranges()))
    {
	print "Error in threshold ranges!\n";
	exit $ERRORS{'UNKNOWN'};
    }
}

######
#
sub print_version()
{
    print "$0 version $VERSION\nwritten by $AUTHOR\n";
}

######
#
sub print_usage()
{
    print "Usage: $0 -s <src> (-e | (-t <type> (-i <index>) -p <param>)) "
	. "[-w <warn> -c <crit>] [-o <orb>] [-v verbose]\n";
}

######
#
sub print_help()
{
    print_version();
    print_usage();
    print "\n";
    print " Check on ORB status values for the source at the specified ORB\n";
    print " Check is performed from the Nagios server, not remotely\n";
    print "\n";
    print "-s  (--source)  = The source description to fetch\n";
    print "-e  (--exists)  = Just check that the source exists and is\n";
    print "                  fresher than -w and -c (in minutes)\n";
    print "-o  (--orb)     = The ORB to look at (addr:port, default: $ORB)\n";
    print "-w  (--warn)    = Nagios range phrase ([@][min:]max) to " 
	. "trigger a warning\n";
    print "-c  (--crit)    = Nagios range phrase ([@][min:]max) to "
	. "trigger a critical\n";
    print "\n";
    print "Defining -t, -i and -p will attempt to parse a pforbstat packet.\n";
    print "-t  (--type)    = Type of the object to check\n";
    print "                  (one of \"$CLIENT_TYPE\",
 \"$SOURCE_TYPE\", \"$SERVER_TYPE\")\n";
    print "-i  (--index)   = The index of the object, specific to the type\n";
    print "                  (\"$CLIENT_TYPE\" requires a number,\n";
    print "                   \"$SERVER_TYPE\" ignores index,\n";
    print "                   \"$SOURCE_TYPE\" requires a source name/type)\n";
    print "-p  (--param)   = Parameter name to monitor\n";
    print "\n";
    print "-h  (--help)    = This help message\n";
    print "-V  (--version) = The version of this script\n";
    print "-v  (--verbose) = The verbosity of the output\n";
    print "\n";
}

######
# Get the latest orbstat packet for the given source. This involves
# opening the orb connection, getting a packet, closing the connection,
# and returning the packet.
#
# Param: source name
# Returns: orbstat packet contents and metadata 
#   ($pktid, $srcname, $time, $packet, $num_bytes) 
#   or null if no packet collected
sub get_latest_orbstat_packet($)
{
    my ($source_name) = shift;
    my ($orb);
    my ($pktid, $srcname, $time, $packet, $num_bytes);

    $orb = orbopen("$ORB", "r&");
    
    orbselect($orb, "$source_name");

    ($pktid, $srcname, $time, $packet, $num_bytes) =
    orbget($orb, "ORBNEWEST");

    orbclose($orb);

    if (defined $pktid)
    {
	return ($pktid, $srcname, $time, $packet, $num_bytes);
    }
    else
    {
	return undef;
    }
}

######
# Check to see if the argument packet is within the recent window.
# Param: orbstat packet id, source name, time, packet, and num_bytes
#   (As returned by get_latest_orbstat_packet())
# Return: (error code from %ERRORS, Description)
sub check_recent_packet_exists($ $ $ $ $)
{
    my ($pktid, $source_name, $packet_time, $raw_packet, $num_bytes) = @_;
    my ($current_time, $time_difference); 
    my ($result, $packet);

    if ((!defined $pktid) || (!defined $source_name) ||
	(!defined $packet_time) || (!defined $raw_packet) ||
	(!defined $num_bytes))
    {
	return ($ERRORS{'UNKNOWN'}, "ERROR");
    }

    # get current time
    $current_time = now();
   
    # compare with packet time
    $time_difference = $current_time - $packet_time;

    # return result
    return categorize_return_value($time_difference);
}

######
# Check to see if the value of the argument in the packet
# is within the recent window.
# Param: orbstat packet id, source name, time, packet, and num_bytes, 
#                  type, index, param
#   (As returned by get_latest_orbstat_packet())
# Return: (error code from %ERRORS, Description)
sub check_recent_pforbstat_packet_value($ $ $ $ $ $ $ $)
{
    my ($pktid, $source_name, $packet_time, $raw_packet, $num_bytes,
	$type, $index, $param) = @_;
    my ($packet_value, $pf, $pf_type, $pf_index); 
    my ($result, $packet);

    if ((!defined $pktid) || (!defined $source_name) ||
	(!defined $packet_time) || (!defined $raw_packet) ||
	(!defined $num_bytes) || (!defined $type) || (!defined $param))
    {
	return ($ERRORS{'UNKNOWN'}, "ERROR");
    }
    
    if ($type !~ /$TYPE_REGEX/)
    {
	return ($ERRORS{'UNKNOWN'}, "ERROR");
    }

    # verify packet really is an orbstat packet    
    if (($result, $packet) = unstuffPkt($source_name, $packet_time, 
					$raw_packet, $num_bytes))
    {

 	return ($ERRORS{'UNKNOWN'}, "BAD PACKET");
    }

    if (!defined $packet)
    {
 	return ($ERRORS{'UNKNOWN'}, "NO PACKET");
    }

    my ($packet_type, $packet_desc) = $packet->PacketType();

    if ($packet_type eq 'Pkt_pf')
    {
	return ($ERRORS{'UNKNOWN'}, "BAD PACKET");
    }
    
    # get packet value
    $pf = $packet->pf;
    foreach $pf_type (pfget($pf, $type))
    {
	if (!defined $pf_type) # check sanity of type
	{
	    return ($ERRORS{'UNKNOWN'}, "Type not found in packet");
	}
	if ($type eq $SERVER_TYPE)
	{
	    $packet_value = ${$pf_type}{$param};
	}
	else # go one layer deeper
	{
	    if (!defined ${$pf_type}{$index})
	    {
		return ($ERRORS{'UNKNOWN'}, 
			"Index not found in type");		
	    }
	    $packet_value = ${$pf_type}{$index}{$param};
	}
    }
    # return result
    if (!defined $packet_value)
    {
	return ($ERRORS{'UNKNOWN'}, "NO VALUE");
    }

    if ((defined $opt_warn) && (defined $opt_crit))
    {
	return categorize_return_value($packet_value);
    }
    else
    {
	return ($ERRORS{'OK'}, $packet_value);
    }
}

######
# Print the results in a nagios friendly format given a result code 
# and possibly some performance data.
# Param: result_code - A scalar from %ERRORS
# Param: result_perf - A scalar performance value that was fetched
# Param: result_descr - A short description (1-2 words) describing the
#                       performance value (ie "descr = $result_perf")
sub print_results($ $ $)
{
    my ($result_code, $result_perf, $result_descr) = @_;
    my ($prefix);

    SWITCH :
    {
	if ($result_code == $ERRORS{'OK'})
	{
	    $prefix = "ORBSTAT OK:";
	    last SWITCH;
	}
	if ($result_code == $ERRORS{'WARNING'})
	{
	    $prefix = "WARNING:";
	    last SWITCH;
	}
	if ($result_code == $ERRORS{'CRITICAL'})
	{
	    $prefix = "CRITICAL:";
	    last SWITCH;
	}
	if ($result_code == $ERRORS{'UNKNOWN'})
	{
	    $prefix = "UNKNOWN:";
	    last SWITCH;
	}
    }
    print "$prefix $result_descr = $result_perf "
	. "| \'$result_descr\' = $result_perf\n";
}

######
# Parse and check warn and critical range arguments from command line
# Nagios-style ranges (see below) into a set of global variables
#
# [@]start:end
#
#Notes:
#- start > end>
#- start and ":" is not required if start=0
#- if range is of format "start:" and end is not specified, 
#    assume end is infinity
#- to specify negative infinity, use "~"
#- alert is raised if metric is outside start and end range
#   (inclusive of endpoints)
#- if range starts with "@", then alert if inside this range
#   (inclusive of endpoints)
# Return "0" if there was an error parsing
sub parse_ranges()
{
    # Handle warning now
    if ($opt_warn =~ /^(\@?)(-?\d*\.?\d*)$/)
    {
	$warn_low = 0;
	$warn_hi = $2;
	$warn_at = $1;
    }
    else
    {
	($warn_at, $warn_low,$warn_hi) = ($opt_warn =~ /(\@?)(~|-?\d*\.?\d*):?(-?\d*\.?\d*)/);

	if (($warn_low eq "") && ($warn_hi eq ""))
	{
	    return 0;
	}
	if (($warn_low ne "") && ($warn_hi ne "") && ($warn_low ne "~")
	    && ($warn_low > $warn_hi))
	{
	    return 0;
	}
	if (($warn_low eq "") && ($warn_hi ne ""))
	{
	    $warn_low = 0;
	}
	if ($warn_low eq "~") { $warn_low = ""; }
    }

    # Handle critical now
    if ($opt_crit =~ /^(\@?)(-?\d*\.?\d*)$/)
    {
	$crit_low = 0;
	$crit_hi = $2;
	$crit_at = $1;
    }
    else
    {
	($crit_at, $crit_low, $crit_hi) = ($opt_crit =~ /(\@?)(~|-?\d*\.?\d*):?(-?\d*\.?\d*)/);
	if (($crit_low eq "") && ($crit_hi eq ""))
	{
	    return 0;
	}

	if (($crit_low ne "") && ($crit_hi ne "") && ($crit_low ne "~")
	    && ($crit_low > $crit_hi))
	{
	    return 0;
	}
	
	if (($crit_low eq "") && ($crit_hi ne ""))
	{
	    $crit_low = 0;
	}
	if ($crit_low eq "~") { $crit_low = ""; }
    }

    return 1;
}
######
# Check a value against the inputted warning and critical ranges.
#
# Param: Value to check
# Return: (error code from %ERRORS, Description)
sub categorize_return_value($)
{
    my ($return_value) = shift;
    
    if ($VERBOSE)
    {
	if (defined $return_value)
	{
	    print "Value being compared: $return_value\n"; 
	}
	if ((defined $warn_at) && (defined $warn_low) && (defined $warn_hi))
	{
	    print "Warning @/low/high: $warn_at/$warn_low/$warn_hi\n";
	}
	else
	{
	    print "Not all warning values defined!\n";
	}
	if ((defined $crit_at) && (defined $crit_low) && (defined $crit_hi))
	{
	    print "Critical @/low/high: $crit_at/$crit_low/$crit_hi\n";
	}
	else
	{
	    print "Not all critical values defined!\n";
	}
    }

    # Check to see if it is critical first
    if (check_range($return_value, $crit_at, $crit_low, $crit_hi))
    {
	return ($ERRORS{'CRITICAL'}, $return_value);
    }

    # Check to see if it is worth a warning
    if (check_range($return_value, $warn_at, $warn_low, $warn_hi))
    {
	return ($ERRORS{'WARNING'}, $return_value);
    }

    # else, return an okay
    return ($ERRORS{'OK'}, $return_value);
}

######
# Check to see if a particular value falls within a given range.
# Assumes hi and low values are not BOTH empty, but returns 1 if they are 
# 
# Param: $test_val - The value in question
# Param: $at - "@" or "" if checking in or out of the range (see Nagios range)
# Param: $low_val - The low value of the range, "" for negative infinity
# Param: $high_val - The high value of the range, "" for infinity
# Return: 1 if the value is in the range, 0 if not
sub check_range($$$$)
{
    my ($test_val, $at, $low_val, $high_val) = @_;

    # should already be checked before we get here, but...
    if (((!defined $low_val) && (!defined $high_val)) 
	|| (($low_val eq "") && ($high_val eq ""))) { return 1; }

#   print "testing val: $test_val, at: $at, low: $low_val, hi: $high_val\n"; #debug

    if ($at) # looking for inside range 
    {
	if (($low_val eq "") && ($test_val < $high_val)) { return 1; }
	if (($low_val eq "") && ($test_val > $high_val)) { return 0; }
	if (($high_val eq "") && ($test_val > $low_val)) { return 1; }
	if (($high_val eq "") && ($test_val < $low_val)) { return 0; }
	if (($test_val > $low_val) && ($test_val < $high_val)) { return 1; }
	# didnt catch any, so we must be outside the range
	return 0;
    }
    else # looking for outside range
    {
	if (($low_val eq "") && ($test_val > $high_val)) { return 1; }
	if (($low_val eq "") && ($test_val < $high_val)) { return 0; }
	if (($high_val eq "") && ($test_val < $low_val)) { return 1; }
	if (($high_val eq "") && ($test_val > $low_val)) { return 0; }
	if (($test_val < $low_val) || ($test_val > $high_val)) { return 1; }
	# didnt catch any, so we must be outside the range
	return 0;
    }
}

######
# Converts a pforbsta source request including a name into a number, but
#   ONLY for pf/orbstat packets. All others just get echoed back normally.
# Param: The source being requested, possibly in the format:
#   mercali:roadnet/pf/orbstat
#   igpprt.ucsd.edu:anza/pf/orbstat
#   roadnet-orb:6580/pf/orbstat
#   1.2.3.4:6510/EXP/FOO
# Return: A source that can be used.
#   1.2.3.4:1234 (All numeric IP and port)
sub convert_pforbstat_to_numbers($)
{
    my ($orig_source) = shift;
    my ($orig_addr, $orig_port, $orig_chan);
    my ($new_addr, $new_port, $return_source);
    
    if (($orig_addr, $orig_port, $orig_chan) = 
	($orig_source =~ /(.*):(.+?)(\/.*)/))
    {
	if ($VERBOSE)
	{
	    print "Original source string: [$orig_source]\n";
	    print "Original source address, port, channel: "
		. "$orig_addr, $orig_port, $orig_chan\n";
	}

	# See if it is even worth translating	
	if ($orig_chan eq "/pf/orbstat")
	{
	    
	    # Look up the address
	    $new_addr = inet_ntoa(inet_aton($orig_addr));
	    
	    # Look up the port
	    if ($orig_port =~ /\D+/)
	    {
		$new_port = pfget($ORBSERVER_NAMES_FILE, $orig_port);
	    }
	    else
	    {
		$new_port = $orig_port;
	    }

	    $return_source = "$new_addr:$new_port$orig_chan";
	    
	    if ($VERBOSE)
	    {
		print "Translated source address, port, channel: "
		    . "$new_addr, $new_port, $orig_chan\n";
		print "Translated source string: [$return_source]\n";
	    }
	    return $return_source;
	}
    }

    # all other cases wind up here
    return $orig_source;
}
