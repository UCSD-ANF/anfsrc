# Prototype script to display images and waveforms from Antelope ORB
# 
# Kent Lindquist
# Lindquist Consulting
# 2002

package require Tclx

set auto_path "$auto_path $env(ANTELOPE)/lib"

#scaffolding while Mytclorb is in LINDCNS repository:
if { [info exists env(LINDCNS)] } {
	set auto_path "$auto_path $env(LINDCNS)/lib"
	set mytclorbdir $env(LINDCNS)/lib
} else {
	set mytclorbdir $env(ANTELOPE)/lib
}
package ifneeded Mytclorb 3.0 [list load [file join $mytclorbdir "libmytclorb.so"] Mytclorb]

package require Orb
package require Mytclorb
package require Rtd

proc init_globals {} {
	global orbname src src_regexp src_descrip

	set pf orbmonimg

	global wforb rtd_scale
	set wforb [pfget $pf wforb]
	set src [pfget $pf wfsrc]
	set src_regexp [pfget $pf wfsrc_regexp]
	set src_descrip [pfget $pf wfdescription]
	set rtd_scale [pfget $pf rtd_scale]

	global imgsrc_regexp imgorb
	set imgorb [pfget $pf imgorb]
	set imgsrc_regexp [pfget $pf img_regexp]

	global sleeptime_sec elapsed elapsed_label mylabel
	global myurl
	set sleeptime_sec 1
	set elapsed 0
	set elapsed_label "Awaiting image packet..."
	set mylabel "Awaiting image packet..."
	set myurl "Awaiting image packet..."

	global curimage oldimage delay curid oldid
	set curid -1
	set oldid -1
	set curimage ""
	set oldimage ""
	set delay 30

	global padx pady
	set padx 20
	set pady 20

	global cwidth cheight
	set cwidth 1000
	set cheight 800

	global max_image_width max_image_height
	set max_image_width 640
	set max_image_height 480

	global htot
	#set htot 42
	set htot 56

	global wtot
	set wtot 2000

	global imagetime 
	set imagetime -1
}

proc init_windows {} {
	global maxrow imgsrc_regexp reap myurl wforb
	global htot wtot cwidth cheight src_descrip
	global imgorb

	wm title . "development prototype"

	frame .i
	grid .i -column 0 -row 0 -sticky ew
	grid rowconfigure . 0 -weight 0
	#pack .i -side top -fill x -expand yes
	
	label .i.llbl -textvariable mylabel -bg white
	label .i.rlbl -textvariable elapsed_label -anchor e \
		      -fg red -justify right -bg lightblue
	grid .i.llbl .i.rlbl -sticky ew
	grid columnconfigure .i 0 -weight 1
	grid columnconfigure .i 1 -weight 0
	#pack .i.rlbl -side right 
	#pack .i.llbl -side left -fill x -expand yes

	#grid .i.rlbl -column 2 -row 0 -sticky w

	bind .i.rlbl <Enter> {
		if { ! [info exists .z] } {
			label .z -text "Image Packet Latency" -bg yellow -font [font create -size 10]
			place .z -anchor ne -in .i.rlbl -x %x -y %y 
		}
	}

	bind .i.rlbl <Motion> {
		place .z -anchor ne -in .i.rlbl -x %x -y %y 
	}

	bind .i.rlbl <Leave> {
		destroy .z
	}

	label .url -textvariable myurl -bg chartreuse -justify center
	grid .url -column 0 -row 1 -sticky ew
	grid rowconfigure . 1 -weight 0

	canvas .c -bg beige
	grid .c -column 0 -row 2 -sticky nsew
	grid rowconfigure . 1 -weight 1
	grid columnconfigure . 0 -weight 1
	set maxrow 2

	frame .rf
	grid .rf -column 0 -row 3 -sticky ew
	grid rowconfigure . 1 -weight 0
	grid columnconfigure . 0 -weight 1
	
	canvas .rf.rc 
	bind .rf.rc <Configure> "+set_tscroll %w"
	frame .rf.rc.f

	.rf.rc.f configure -width $wtot -height $htot

	if {$cwidth > $wtot} {set cwidth $wtot}
	if {$cheight > $htot} {set cwidth $htot}

	#.rf.rc configure -width $wtot -height $htot
	.rf.rc configure -height $htot

	.rf.rc create window 0 0 -window .rf.rc.f
	place .rf.rc.f -x 0 -y 0

	set orbfd [orbopen $imgorb r&]
	orbselect $orbfd $imgsrc_regexp
	set reap [myorbreapstart $orbfd]

	# start_rtd .r $orbname $src $src_regexp 60 2500
	# start_rtd .rf.rc.f.r2 : AK_TNA_BHZ AK_TNA_BHZ/GCF 600 250
	global wforb src src_regexp rtd_scale
	start_rtd .rf.rc.f.r2 $wforb $src $src_regexp 600 $rtd_scale

	scrollbar .rf.xscroll -orient horiz -command set_tview
	pack .rf.xscroll -side bottom -expand yes -fill x
	pack .rf.rc -side bottom -fill both -expand yes

	label .rf.name -textvariable src_descrip -bg lightblue -justify center
	pack .rf.name -side bottom -fill x 

	button .q -text Quit -bg red -command "destroy ."
	set row [incr maxrow]
	grid .q -column 0 -row $row -sticky ew
	grid rowconfigure . $row -weight 0

	wm resizable . 0 0
}

proc set_tscroll {w} {
	global wtot

	if {[info exists wtot] == 0} return

	set first [lindex [.rf.xscroll get] 0]
	set last [expr $first+double($w)/double($wtot)]
	if {$last > 1.0} {
		set first [expr 1.0-($last-$first)]
		set last 1.0
	}
	.rf.xscroll set $first $last
}

proc set_tview args {
	global wtot
	
	if {[info exists wtot] == 0} return
	set arg [lvarpop args 0]
	switch $arg {
	moveto {
		set l [.rf.xscroll get]
		set first [lvarpop args 0]
		if {$first < 0.0} {set first 0.0}
		set delta [expr $first-[lindex $l 0]]
		set last [expr [lindex $l 1]+$delta]
		if {$last > 1.0} {
			set delta [expr 1.0 - [lindex $l 1]]
			set first [expr [lindex $l 0] +$delta]
			set last 1.0
		}
		set x [expr -int($first*$wtot+0.1)]
		place .rf.rc.f -x $x
		.rf.xscroll set $first $last
		}
	default
		{}
	}
}

proc resize_canvas {} {
	global curimage padx pady

	set refresh 0 
	
	if { $curimage == "" } { return }

	set bbwidth [lindex [grid bbox . 0 1] 2]
	set bbheight [lindex [grid bbox . 0 1] 3]

	set cw [max [expr $bbwidth - 2] [expr [image width $curimage] + $padx]]
	set ch [max [expr $bbheight - 2] [expr [image height $curimage] + $pady]]

	if { $cw != [lindex [.c configure -width] 4] } {	

		.c configure -width $cw
		incr refresh
	}

	if { $ch != [lindex [.c configure -height] 4] } {

		.c configure -height $ch
		incr refresh
	}

	set imgcoords [.c coords curimage]
	set imgx [lindex $imgcoords 0]
	set imgy [lindex $imgcoords 1]
	
	set xctr [expr $cw / 2]
	set yctr [expr $ch / 2]

	.c move curimage [expr $xctr - $imgx] [expr $yctr - $imgy]

	if { $refresh } {
		refresh_rtds
	}
}

proc display_next {} {
	global delay curid curimage oldimage
	
	set cw [expr [lindex [.c configure -width] 4] / 2]
	set ch [expr [lindex [.c configure -height] 4] / 2]

	set oldid $curid
	set curid [.c create image $cw $ch -image $curimage -tag curimage]
	if { $oldimage != "" } {
		image delete $oldimage
	}
	if { $oldid != -1 } {
		.c delete $oldid
	}

	resize_canvas
}

proc refresh_label { info } {
	global mylabel

	set pktid [lindex $info 0]
	set time [lindex $info 1]
	set srcname [lindex $info 2]
	set size [lindex $info 3]

	set mylabel \
		[format "Last: %s, #%d at %s UTC" \
		 $srcname $pktid [strtime $time]]

	update
}

proc plot_imagetime {} {
	global imagetime

	if { $imagetime < 0 } { return }

	.rf.rc.f.r2 tmark $imagetime #ff0000 0.0 1.0 line
	
	after 1000 plot_imagetime
}

proc limit_imagesize { origimage } {
	
	global max_image_width max_image_height

	set curwidth [image width $origimage]
	set curheight [image height $origimage]

	set widthfix [expr ceil(double($curheight)/double($max_image_height))]
	set heightfix [expr ceil(double($curwidth)/double($max_image_width))]

	set factor [int [max $widthfix $heightfix]]

	if { $factor > 1.0 } {

        	set curimage [image create photo]
        	$curimage copy $origimage -subsample $factor
        	image delete $origimage

	} else {

		set curimage $origimage
	}

	return $curimage
}

proc tryreap {} {
	global reap mylabel elapsed sleeptime_sec 
	global orbname curimage oldimage myurl
	global imagetime
	set pkth [myorbreap $reap]

	set elapsed [expr $elapsed + $sleeptime_sec]

	if { $pkth != 0 } {
		set elapsed 0
		# set mypkt [orbpktgetraw $pkth]
		set myurl "Updating image..."
		.url configure -bg yellow
		update idletasks
		if { ! [catch {myorbpktunstuffdata $pkth} mypktraw] } {
			set mypkt [myorbpktgetraw $mypktraw]
			set myurl [myorbpktgetdescrip $mypktraw]
			.url configure -bg chartreuse -fg black
			set hdrinfo [myorbpktgethdr $pkth]
			refresh_label $hdrinfo
			set imagetime [lindex $hdrinfo 1]
			myorbpktfree $pkth

			if { $curimage != "" } { set oldimage $curimage }
			set curimage [image create photo -data $mypkt]
			set curimage [limit_imagesize $curimage]
		} else {

			set myurl "Awaiting image packet..."
			.url configure -bg chartreuse -fg black
		}

		after idle display_next
	}
		
	after [expr $sleeptime_sec * 1000] tryreap
}

proc update_elapsed { junk junk2 junk3 } {
	global elapsed elapsed_label

	set elapsed_withspace [strtdelta $elapsed]
	set elapsed_label [string trim $elapsed_withspace]
}

proc refresh_rtds {} {
	global rtd_widgets 
	global rtd_orbnames 

	update idletasks

	for {set i 0} { $i < [llength $rtd_widgets] } { incr i } {

		set w [lindex $rtd_widgets $i]
		set orbname [lindex $rtd_orbnames $i]

		$w clear
		testrb_$orbname after [$w get tleft]
	}

	set_tview moveto 1.0
}

proc start_rtd {w orbname src src_regexp twin scale } {

	global rtd_widgets rtd_orbnames maxrow htot wtot

	lappend rtd_widgets $w
	lappend rtd_orbnames $orbname

	set tracecolor \#ffff00

	orb testrb_$orbname $orbname r
	orbchannel testrb_$orbname.$src

	       #-twin $twin -width [lindex [.c configure -width] 4] \

	rtd $w -filter "BW 0.01 1 0 0" -source testrb_$orbname.$src \
	       -twin $twin -width $wtot \
	       -height $htot -abottom [expr -1 * $scale] -atop $scale \
	       -showasbitmap 0 -trace_color $tracecolor

	$w tlabel on

	set row [incr maxrow]
	#pack $w -side top -fill both -expand yes
	place $w -x 0 -y 0 -width $wtot -height $htot

	testrb_$orbname start
	testrb_$orbname select $src_regexp

	set tmin 9999999999.0
	set t0 [$w get tleft]
	if {$t0 < $tmin && $t0 > 1000000.0} {set tmin $t0}
	$w clear
	testrb_$orbname after $tmin

	$w animate 100
	#$w change -twin $twin
}

init_globals

trace variable elapsed w update_elapsed

init_windows

tryreap

after 1000 {set_tview moveto 1.0}
